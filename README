This repo contains some scripts for use with
[Open Shading Language in Blender Cycles](https://wiki.blender.org/index.php/User:DingTo/OpenShadingLanguage). Some are OSL scripts that may be used directly, while others are Python scripts that generate OSL scripts.

**Copyright**: All OSL scripts (whether generated by Python scripts or included in this repo) are
licensed [CC0](https://creativecommons.org/publicdomain/zero/1.0/). The Python scripts are
licensed CC-BY.

Script Generators
=================

These scripts generate OSL scripts based on the supplied command parameters, such as
operand types, operation to perform, and name to give the shader. Operand types can
be most of the types recognized by OSL, such as `float`, `point`, `color`, often even
`closure color`.

* `osl-gen-compare`

    generates a comparison between two inputs, and uses the result of that comparison to
    select from one of two other inputs for its output: it returns the first of the selection
    inputs if the comparison is false, the second if it is true. For example, the command

        ./osl-gen-compare --comptype=float --seltype=color --name=color_max lt

    generates a computation node script like this:

        shader color_max
          (
            float Cmp1 = float(0),
            float Cmp2 = float(0),
            color Arg1 = color(0),
            color Arg2 = color(0),
            output color Out = color(0)
          )
          {
            Out = Cmp1 < Cmp2 ? Arg2 : Arg1;
          } /*color_max*/

    which returns the selection input (`Arg1` or `Arg2` corresponding to the larger of the two
    same-numbered comparison inputs (`Cmp1` or `Cmp2`).

* `osl-gen-mix`

    generates a multiway mixer of 2 or more inputs according to their relative assigned weights.
    Thus, the actual value of each weight does not matter, only its proportion in comparison
    to the total sum (which must not be 0). For comparison, Blender’s “MixRGB” and “Mix Shader”
    node types take two inputs and a single weight factor that blends between the two inputs.
    Whereas the mixers generated by `osl-gen-mix` can have any number of inputs. Also, you can
    ask for an output giving the summed input weights, to allow correct cascading of multiple
    multiway mixers, so that they behave like a single one. For example, the command

        ./osl-gen-mix --name=mix3_shader --type=closure\ color --inputs=3

    generates a shader node script like this:

        shader mix3_shader
          (
            closure color Input1 = 0,
            float Weight1 = 1,
            closure color Input2 = 0,
            float Weight2 = 1,
            closure color Input3 = 0,
            float Weight3 = 1,
            output closure color Output = 0
          )
          {
            float Weight = Weight1 + Weight2 + Weight3;
            Output = (Input1 * Weight1 + Input2 * Weight2 + Input3 * Weight3) * (1 / Weight);
          } /*mix3_shader*/

    which can be used to mix the outputs of 3 other Cycles shaders in any relative proportions.

* `osl-gen-multi`

    generates a cascaded arithmetic or comparison operation across multiple operands.
    The currently-supported operations are

    + `add` -- sum of all the operands
    + `mul` -- product of all the operands
    + `max` -- maximum of all the operands
    + `min` -- minimum of all the operands

    For example, the command

        ./osl-gen-multi --name=sum --type=float --input=5 add

    generates a computation node script like this

        shader sum
          (
            float Input1 = float(0),
            float Input2 = float(0),
            float Input3 = float(0),
            float Input4 = float(0),
            float Input5 = float(0),
            output float Output = float(0)
          )
          {
            Output = Input1 + Input2 + Input3 + Input4 + Input5;
          } /*sum*/

    which computes the sum of 5 input float values.

* `osl-gen-ramp`

    generates a ramp mapping from an input float value to an output
    value of some given type, interpolating between specified control
    points. The mapping can be piecewise-linear, or one of the types
    of spline curves supported by OSL’s built-in “spline” function.

* `osl-gen-panel`

    generates a node that can be used to render a panel of multicoloured
    lights or an array of windows on a highrise building.

* `osl-gen-rand-pick`

    generates a node that randomly picks from its inputs based on assigned
    relative probability weights.

* `osl-gen-rescale`

    generates a node that applies a scalar linear transformation of its
    input. That is, the input (which can be of any valid OSL type) has
    a midpoint value (of the same type) subtracted from it, the result
    is multiplied by a real value, and then the midpoint value is added
    back to give the output.

* `osl-gen-select`

    generates a node that selects from one of its inputs based on an input
    integer within a specified range. The selection type may be any of the
    usual OSL types, including “closure color”. You can specify a default
    for the selector value if the actual value is outside the valid range.

    For example, the command

        ./osl-gen-select --seltype=closure\ color --name=select4_shader 1 4

    generates a shader node script like this

        shader select4_shader
          (
            int Sel = 0,
            closure color In1 = 0,
            closure color In2 = 0,
            closure color In3 = 0,
            closure color In4 = 0,
            output closure color Out = 0
          )
          {
            if (Sel == 1)
                Out = In1;
            else if (Sel == 2)
                Out = In2;
            else if (Sel == 3)
                Out = In3;
            else if (Sel == 4)
                Out = In4;
          } /*select4_shader*/

    which selects from 4 different input shaders according to the Sel value.

* `osl-gen-spherical-harmonics`

    generates a node that outputs a mix of spherical harmonics up to a
    specified order. The order must be a non-negative integer; if this is
    `l`, then the harmonics are numbered with integers in the range from
    `-l` to `+l` inclusive, for a total of `2 * l + 1` components. By
    assigning different weights to the harmonics, you can get interesting
    spherical intensity distributions. For example, such a distribution
    could be applied to a point lamp, to give directional emission effects.

    For example, the command

        ./osl-gen-spherical-harmonics --name=spherical_1 1

    generates this shader:

        shader spherical_1
          (
            float Wm1 = 0,
            float W0 = 0,
            float Wp1 = 0,
            normal Direction = N,
            output float Result = 1
          )
          /* generated by osl-gen-spherical-harmonics. */
          {
            float len_xy = hypot(Direction[1], Direction[0]);
            float len_xyz = hypot(Direction[2], len_xy);
            float sin_theta = len_xy / len_xyz;
            float cos_theta = Direction[2] / len_xyz;
            float phi = atan2(Direction[1], Direction[0]);
            Result = max
              (
                    W0 * 0.4886025 * cos_theta
                +
                    Wp1 * -0.3454941 * cos(1 * phi) * sin_theta
                +
                    Wm1 * 0.3454941 * cos(1 * phi) * sin_theta,
                0
              );
          } /*spherical_1*/

    which has 3 weight inputs.

* `osl-gen-spherical-lobes`

    generates a node that outputs an angle-dependent function consisting
    of a product of two sums of cosine terms. Each term defines a “lobe”
    or “peak” in a particular orientation. One set of terms is a function
    of the axial angle (symmetrical with respect to the positive Z-axis)
    while the other set of terms is a function of the radial angle (varying
    around the positive Z-axis). You specify the number of terms along
    each dimension; they cannot both be zero.

    For each term, you get an “intensity” input and a “power” input.
    The intensity input controls the strength of that component, while
    the “power” controls the sharpness of the peak.

    The resulting intensity distribution could, for example, be
    applied to a point lamp, to give directional emission effects.


Prewritten Scripts
==================

* `amplify.osl`

    Multiplies a shader output by a given factor. If the factor is greater than 1,
    this amplifies the shader; if less than 1, it attenuates it.

* `atan2.osl`

    This is an alternative to the “atan” function in Cycles’s built-in “Math” node.
    Unlike that, this one takes both its X- and Y- inputs into account, and returns
    an angle that can cover the full circle.

* `convert_angles.osl`

    This node converts between angles expressed as degrees, radians and fractions
    of a circle.

* `pi.osl`

    Returns the specified multiple of pi.

* `polar_to_rect.osl`

    Interprets its input point as (*r*, *theta*, *phi*) polar coordinates (angles
    *theta* and *phi* being in radians), and returns the output as converted
    (*x*, *y*, *z*) Cartesian coordinates.

    This can be used for 3D or 2D coordinates; for 2D, leave the input *phi* as
    zero and the output *z* will be zero and can be ignored.

* `rand_int.osl`

    Generates a pseudorandom uniformly-distributed integer over a specified
    range. The output depends only on the integer parts of the input coordinate
    and time values; you can get a different granularity simply by scaling these.

* `rect_to_polar.osl`

    Converts its input (*x*, *y*, *z*) Cartesian coordinates to (*r*, *theta*, *phi*)
    polar coordinates as its output.

    This can be used for 3D or 2D coordinates; for 2D, leave the input *z* as
    zero and the output *phi* will be zero and can be ignored.

* `rotate_coords.osl`

    This is a simpler alternative to Cycles’ “Vector Mapping” node. This just does
    rotation of a vector by a given angle about a given axis. Also the axis
    and angle are node inputs, and so can be computed from other values.

* `scale_coords.osl`

    This is a simpler alternative to Cycles’ “Vector Mapping” node. This just does
    uniform scaling of coordinates. Also the scale factor is a node input, and so
    can be computed from other values.

Lawrence D'Oliveiro <ldo@geek-central.gen.nz>
2019 July 12
