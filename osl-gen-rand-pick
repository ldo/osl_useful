#!/usr/bin/python3
#+
# This script generates an Open Shading Language shader that returns
# one of its inputs, randomly-chosen according to relative probability
# weights. Invoke it as follows:
#
#     osl-gen-rand-pick [--axis=«axis»] --name=«name» [--time-step=«step-type»]
#         --type=«type» --inputs=«inputs»
#
# where
#     * «axis» is 0, 1 or 2 to indicate which of the 3 available axes
#       of cell noise to pick from, to avoid correlations between
#       different nodes using the same random seed (defaults to 0 if
#       omitted)
#     * «name» is the name to give to the shader
#     * «type» is the type of the inputs and output. This can be just
#       about any OSL type, e.g. “float”, “color”, “point”.  It can
#       also be “closure color” to create a random-picker shader.
#     * «inputs» is the integer number of inputs that the shader will
#       pick from (must be least 2).
#
# Copyright 2016-2020 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY <http://creativecommons.org/licenses/by/4.0/>.
#-

import sys
import getopt

step_functions = \
    {
        "step" : None,
        "linear" : "linearstep",
        "smooth" : "smoothstep",
    }

opts, args = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ["axis=", "inputs=", "name=", "time-step=", "type="]
  )
axis = 0
nr_inputs = None
shader_name = None
op_type = None
time_step = "step"
for keyword, value in opts :
    if keyword == "--axis" :
        axis = int(value)
        assert axis in range(0, 3)
    elif keyword == "--inputs" :
        nr_inputs = int(value)
        assert nr_inputs > 1
    elif keyword == "--name" :
        shader_name = value
    elif keyword == "--time-step" :
        time_step = value
        if time_step not in step_functions :
            raise getopt.GetoptError \
              (
                    "unrecognized value for --time-step, must be in %s"
                %
                    ", ".join(sorted(step_functions.keys()))
              )
        #end if
    elif keyword == "--type" :
        op_type = value
    #end if
#end for
if nr_inputs == None or shader_name == None or op_type == None :
    raise getopt.GetoptError("missing --axis, --inputs, --name or --type value")
#end if
is_closure = op_type.startswith("closure")

arg_default = \
  (
        [
            "%(type)s(0)",
            "0",
        ][is_closure]
    %
        {
            "type" : op_type
        }
  )
sum_weights = lambda n : " + ".join("Weight%(i)d" % {"i" : i + 1} for i in range(n))

def pick_input(i) :
    if i > 1 :
        result = \
            (
                    "if (pick >= %(sum_weights)s)\n"
                    "        Output = Input%(i)d;\n"
                %
                    {
                        "sum_weights" : sum_weights(i - 1),
                        "i" : i,
                    }
            +
                pick_input(i - 1)
            )
        if i < nr_inputs :
            result = "else " + result
        #end if
    else :
        result = "else\n        Output = Input1;\n"
    #end if
    return \
        "    " + result
#end pick_input

sys.stdout.write \
  (
        "shader %(name)s\n"
        "  (\n"
        "    point Coord = P,\n"
        "    float Time = 0,\n"
        "%(input_args)s"
        "    output %(type)s Output = %(arg_default)s\n"
        "  )\n"
        "  /* generated by osl-gen-rand-pick. */\n"
        "  {\n"
        "%(pick_x)s"
        "    float pick = x[%(axis)s] * (%(sum_weights)s);\n"
        "%(pick_input)s"
        "  } /*%(name)s*/\n"
    %
        {
            "name" : shader_name,
            "type" : op_type,
            "input_args" :
                "".join
                  (
                        "    %(type)s Input%(i)d = %(arg_default)s,\n"
                        "    float Weight%(i)d = 1,\n"
                    %
                        {
                            "i" : i + 1,
                            "type" : op_type,
                            "arg_default" : arg_default,
                        }
                    for i in range(nr_inputs)
                  ),
            "arg_default" : arg_default,
            "pick_x" :
                (
                    lambda : "    point x = noise(\"cell\", Coord, Time);\n",
                    lambda :
                            "    float time1 = floor(Time);\n"
                            "    float time2 = ceil(Time);\n"
                            "    point x1 = noise(\"cell\", Coord, time1);\n"
                            "    point x2 = noise(\"cell\", Coord, time2);\n"
                            "    float frac = %(step_func)s(time1, time2, Time);\n"
                            "    point x = x1 * (1.0 - frac) + x2 * frac;\n"
                        %
                            {
                                "axis" : axis,
                                "step_func" : step_functions[time_step],
                            },
                )[time_step != "step"](),
            "axis" : axis,
            "sum_weights" : sum_weights(nr_inputs),
            "pick_input" : pick_input(nr_inputs),
        }
  )
