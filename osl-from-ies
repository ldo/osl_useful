#!/usr/bin/python3
#+
# This script generates an OSL shader that outputs a directional
# intensity function corresponding to a given light definition in
# IESNA LM-63 format.
#
# Various online versions of spec:
# <https://seblagarde.wordpress.com/2014/11/05/ies-light-format-specification-and-reader/>
# <http://www.vuw.ac.nz/architecture-onlineteaching/tutorials/lightscape/extras/ies_standard_format.html>
#-

import sys
import os
import math
import enum
import re
import getopt

DEG = math.pi / 180

INTENSITY_CONV_FACTOR = 4 * math.pi / 177.83
  # conversion factor taken from intern/cycles/util/util_ies.cpp in Blender source.
  # See there for derivation of this value.

class IESLight :

    class FormatError(Exception) :

        def __init__(self, msg) :
            self.msg = msg
        #end __init__

    #end FormatError

    class GEOM(enum.IntEnum) :
        VERTICAL_WHEN_AIMED_DOWN = 1
        HORIZONTAL_WHEN_AIMED_DOWN_OR_ROTATED = 2
        HORIZONTAL_WHEN_AIMED_DOWN_NOT_ROTATED = 3
    #end GEOM

    class UNITS(enum.IntEnum) :
        FEET = 1
        METRES = 2
    #end UNITS

    class PHOTOMETRIC(enum.IntEnum) :
        TYPE_C = 1
        TYPE_B = 2
        TYPE_A = 3
    #end PHOTOMETRIC

    def __init__(self, **kwargs) :
        self._attrs = tuple(sorted(kwargs.keys()))
        for key in kwargs :
            setattr(self, key, kwargs[key])
        #end for
    #end __init__

    def __repr__(self) :
        return \
            (
                "%s(%s)"
            %
                (
                    type(self).__name__,
                    ", ".join("%s = %s" % (k, repr(getattr(self, k))) for k in self._attrs),
                )
            )
    #end __repr__

    @classmethod
    def from_stream(celf, fl, ref_filename = None, process_photometric = True) :
        "parses IES data from the file-like object fl, and returns an IESLight" \
        " object. ref_filename is used to interpret relative pathnames within" \
        " the file, namely the TILT=«filename» option."

        FormatError = celf.FormatError

        next_line = None

        def read_multi_line() :
            # reads a line and any following continuation lines,
            # returning it all as one line. Continuation is indicated
            # by space at the end of the preceding line, or at the
            # start of the one following.
            nonlocal next_line
            if next_line != None :
                line = next_line
            else :
                line = fl.readline().rstrip("\n")
            #end if
            while True :
                next_line = fl.readline()
                if next_line == "" :
                    break
                next_line = next_line.rstrip("\n")
                if not (line.endswith(" ") or next_line.startswith(" ")) :
                    break
                line += next_line
            #end while
            return \
                line
        #end read_multi_line

        def read_items_line(cnv) :
            line = read_multi_line()
            raw_items = re.split("\\s+", line.strip())
            if len(raw_items) != len(cnv) :
                raise FormatError \
                  (
                        "wrong nr items on line: expected %d, got %d: %s"
                    %
                        (len(cnv), len(raw_items), repr(line))
                  )
            #end if
            items = []
            for i in range(len(cnv)) :
                try :
                    items.append(cnv[i](raw_items[i]))
                except ValueError :
                    raise FormatError \
                      (
                        "bad %s item[%d] on line: %s" % (cnv[i].__name__, i, repr(line))
                      )
                #end try
            #end for
            return \
                items
        #end read_items_line

        def ensure_increasing(items, what) :
            if not all(items[i] < items[i + 1] for i in range(len(items) - 1)) :
                raise FormatError("%s must all be increasing: %s" % (what, repr(items)))
            #end if
            return \
                items
        #end ensure_increasing

        def parse_tilt() :
            geom_type = read_items_line([lambda x : celf.GEOM(int(x))])[0]
            nr_tilts = read_items_line([int])[0]
            tilt_angles = ensure_increasing(read_items_line([float] * nr_tilts), "tilt angles")
            tilt_factors = read_items_line([float] * nr_tilts)
            return \
                {
                    "geom_type" : geom_type,
                    "nr_tilts" : nr_tilts,
                    "tilt_angles" : tilt_angles,
                    "tilt_factors" : tilt_factors,
                }
        #end parse_tilt

        def expand_phototype_ab(vert_angles, hor_angles, candela_values) :
            # following same processing that Cycles does.
            # Args are lists which are updated in-place.

            # transpose hor ↔ vert
            temp = list \
              (
                list
                  (
                    candela_values[j][i]
                    for j in range(len(hor_angles))
                  )
                for i in range(len(vert_angles))
              )
            candela_values[:] = temp
            temp = vert_angles[:]
            vert_angles[:] = hor_angles
            hor_angles[:] = temp
            nr_vert_angles = len(vert_angles)
            nr_hor_angles = len(hor_angles)

            # normalize/expand vert angles
            if vert_angles[-1] != 90 :
                raise FormatError \
                  (
                    "type-a/b vertical angles don’t end with 90: %.3f" % vert_angles[-1]
                  )
            #end if
            if vert_angles[0] == 0 :
                vert_angles[:] = \
                    (
                        list(90 - vert_angles[i] for i in range(nr_vert_angles - 1, 0, -1))
                    +
                        list(90 + θ for θ in vert_angles)
                    )
                for i in range(nr_hor_angles) :
                    candela_values[i][:] = \
                        (
                            list(candela_values[i][j] for j in range(nr_vert_angles - 2, -1, -1))
                        +
                            candela_values[i]
                        )
                #end for
            elif vert_angles[0] == -90 :
                vert_angles[:] = list(90 + θ for θ in vert_angles)
            #end if

            # normalize/expand hor angles
            if hor_angles[-1] != 90 :
                raise FormatError \
                  (
                    "type-a/b horizontal angles don’t end with 90: %.3f" % hor_angles[-1]
                  )
            #end if
            if hor_angles[0] == 0 :
                hor_angles[:] = \
                    (
                        list(90 - hor_angles[i] for i in range(nr_hor_angles - 1, 0, -1))
                    +
                        list(90 + θ for θ in hor_angles)
                    )
                candela_values[:] = \
                    (
                        list(list(candela_values[i]) for i in range(nr_hor_angles - 1, 0, -1))
                    +
                        candela_values
                    )
            elif hor_angles[0] == -90 :
                hor_angles[:] = list(90 + θ for θ in hor_angles)
            #end if
            hor_angles.append(360)
            candela_values.append(list(candela_values[0]))
        #end expand_phototype_ab

        def expand_phototype_c(vert_angles, hor_angles, candela_values) :
            # following same processing that Cycles does.
            # Args are lists which are updated in-place.

            # normalize vert angles
            if vert_angles[0] == 90 and vert_angles[-1] == 180 :
                vert_angles[:] = list(180 - θ for θ in vert_angles)
            #end if
            if vert_angles[0] != 0 :
                raise FormatError \
                  (
                    "type-c vertical angles don’t start with 0: %.3f" % vert_angles[0]
                  )
            #end if

            # normalize/expand hor angles
            nr_hor_angles = len(hor_angles)
            if hor_angles[0] == 90 :
                hor_angles[:] = list(θ - 90 for θ in hor_angles)
            #end if
            if hor_angles[0] != 0 :
                raise FormatError \
                  (
                    "type-c horizontal angles don’t start with 0: %.3f" % hor_angles[0]
                  )
            #end if
            if nr_hor_angles == 1 :
                hor_angles.append(360)
                candela_values.append(list(candela_values[0]))
            #end if
            for hi_angle in (90, 180) :
                if hor_angles[-1] == hi_angle :
                    hor_angles.extend \
                      (list(
                        2 * hi_angle - hor_angles[i]
                        for i in range(nr_hor_angles - 2, -1, -1)
                      ))
                    candela_values.extend \
                      (list(
                        list(candela_values[i])
                        for i in range(nr_hor_angles - 2, -1, -1)
                      ))
                #end if
            #end for
            if hor_angles[-1] != 360 :
                # put in missing 360° angle with same value as 0°; Cycles
                # does additional check about angle step size, but why bother?
                hor_angles.append(360)
                candela_values.append(list(candela_values[0]))
            #end if
        #end expand_phototype_c

    #begin from_stream
        tilt = None
        while True :
            line = fl.readline()
            if line == "" : # EOF
                raise FormatError("“TILT=” line not found")
            #end if
            line = line.rstrip("\n")
            # ignore everything prior to TILT= line for now
            if line.startswith("TILT=") :
                line = line[5:]
                if line == "INCLUDE" :
                    tilt = parse_tilt()
                elif line != "NONE" :
                    if ref_filename != None :
                        tilt_filename = os.path.realpath \
                          (
                            os.path.join(os.path.split(ref_filename)[0], line)
                          )
                         # interpret relative path as relative to directory containing ref_filename
                    else :
                        tilt_filename = line
                    #end if
                    tilt = parse_tilt(open(tilt_filename, "rt"))
                #end if
                break
            #end if
        #end while
        items = {"tilt" : tilt}
        item_defs = \
            (
                ("nr_lamps", int),
                ("lumens_per_lamp", float),
                ("candela_multiplier", float),
                ("nr_vert_angles", int),
                ("nr_hor_angles", int),
                ("photometric_type", lambda x : celf.PHOTOMETRIC(int(x))),
                ("units_type", lambda x : celf.UNITS(int(x))),
                ("width", float),
                ("length", float),
                ("height", float),
            )
        item_vals = read_items_line(tuple(i[1] for i in item_defs))
        for i in range(len(item_defs)) :
            items[item_defs[i][0]] = item_vals[i]
        #end for
        for valname in \
            (
                "nr_lamps",
                "nr_vert_angles",
                "nr_hor_angles",
                # note width, length and height can be zero or negative
            ) \
        :
            val = items[valname]
            if val <= 0 :
                raise FormatError("%s must be positive: %d" % (valname, val))
            #end if
        #end for
        if items["lumens_per_lamp"] == -1 :
            items["lumens_per_lamp"] = None
        elif items["lumens_per_lamp"] <= 0 :
            raise FormatError \
              (
                "invalid lumens per lamp; must be positive or -1: %.3g" % items["lumens_per_lamp"]
              )
        #end if
        item_vals = read_items_line([float] * 3)
        ballast_factor = item_vals[0]
        ballast_photometric_factor = item_vals[1]
        items["input_watts"] = item_vals[2]
        vert_angles = ensure_increasing \
          (
            read_items_line([float] * items["nr_vert_angles"]),
            "vertical angles"
          )
        hor_angles = ensure_increasing \
          (
            read_items_line([float] * items["nr_hor_angles"]),
            "horizontal angles"
          )
        items["vert_angles"] = vert_angles
        items["hor_angles"] = hor_angles
        candela_values = []
        candela_multiplier = \
            items["candela_multiplier"] * ballast_factor * ballast_photometric_factor
        for i in range(items["nr_hor_angles"]) :
            candela_values.append \
              (
                list
                  (
                    x * candela_multiplier
                    for x in read_items_line([float] * items["nr_vert_angles"])
                  )
              )
        #end for
        items["candela_values"] = candela_values
        if process_photometric :
            for valname in ("nr_vert_angles", "nr_hor_angles", "candela_multiplier") :
                # nr vert/hor angles might be invalidated by transposition in type-A/B
                # processing (below); candela_multiplier has been applied, so no longer needed
                del items[valname]
            #end for
            {
                celf.PHOTOMETRIC.TYPE_A : expand_phototype_ab,
                celf.PHOTOMETRIC.TYPE_B : expand_phototype_ab,
                celf.PHOTOMETRIC.TYPE_C : expand_phototype_c,
            }[items["photometric_type"]](vert_angles, hor_angles, candela_values)
        #end if
        return \
            celf(**items)
    #end from_stream

    @classmethod
    def from_file(celf, filename, process_photometric = True) :
        return \
            celf.from_stream(open(filename, "rt"), filename, process_photometric)
    #end from_file

#end IESLight

#+
# Mainline
#-

opts, args = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ["name="]
  )
shader_name = None
for keyword, value in opts :
    if keyword == "--name" :
        shader_name = value
    #end if
#end for
if shader_name == None :
    raise getopt.GetoptError("missing --name")
#end if
if len(args) != 1 :
    raise getopt.GetoptError("need exactly one arg, the input IES file name")
#end if
light_def = IESLight.from_file(args[0])
sys.stderr.write("light_def = %s\n" % repr(light_def))

# more TBD
